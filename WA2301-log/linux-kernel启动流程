										// \arch\arm\kernel\head.S
ENTRY(stext)							// \arch\arm\kernel\vmlinux.lds.S 内核入口


__switch_data
	b	start_kernel

	start_kernel							// \arch\alpha\boot\bootpz.c
	{
		decompress_kernel()					// \arch\arm\boot\compressed\misc.c
		{
			arch_decomp_setup()
											//Uncompressing Linux... done, booting the kernel.
			do_decompress()

		}
	}







start_kernel()								// \init\main.c
{
	smp_setup_processor_id();
	lockdep_init();
	debug_objects_early_init();
	boot_init_stack_canary();
	cgroup_init_early()
	{
		cgroup_init_subsys()				//[    0.000000] WA2301:Initializing cgroup subsys cpu
	}
	local_irq_disable();
	tick_init();
	boot_cpu_init();
	page_address_init();

	printk(KERN_NOTICE "%s", linux_banner); //[    0.000000] Linux version 3.0.8-FriendlyARM (beta@Founder) (gcc version 4.5.1 (ctng-1.8.1-FA) ) #4 PREEMPT Sat Nov 17 15:17:23 CST 2018

	setup_arch(&command_line);
	mm_init_owner(&init_mm, &init_task);
	mm_init_cpumask(&init_mm);
	setup_command_line(command_line);
	setup_nr_cpu_ids();
	setup_per_cpu_areas();
	smp_prepare_boot_cpu();	/* arch-specific boot-cpu hooks */

	build_all_zonelists(NULL);
	page_alloc_init();

	printk(KERN_NOTICE "Kernel command line: %s\n", boot_command_line);
											//[    0.000000] Kernel command line: root=/dev/mtdblock4 rootfstype=yaffs2 console=ttySAC0,115200 init=/linuxrc androidboot.console=s3c2410_serial0 skipcali=yes ctp=2

	parse_early_param();
	parse_args("Booting kernel", static_command_line, __start___param,
		   __stop___param - __start___param,
		   &unknown_bootoption);

	setup_log_buf(0);
	pidhash_init();
	vfs_caches_init_early();
	sort_main_extable();
	trap_init();
	mm_init();

	sched_init();

	preempt_disable();

	idr_init_cache();
	perf_event_init();
	rcu_init();
	radix_tree_init();

	early_irq_init();
	init_IRQ();
	prio_tree_init();
	init_timers();
	hrtimers_init();
	softirq_init();
	timekeeping_init();
	time_init();
	profile_init();
	call_function_init();

	local_irq_enable();

	kmem_cache_init_late();

	console_init();

	lockdep_info();

	locking_selftest();

	page_cgroup_init();
	enable_debug_pagealloc();
	debug_objects_mem_init();
	kmemleak_init();
	setup_per_cpu_pageset();
	numa_policy_init();

	sched_clock_init();
	calibrate_delay();
	pidmap_init();
	anon_vma_init();

	thread_info_cache_init();
	cred_init();
	fork_init(totalram_pages);
	proc_caches_init();
	buffer_init();
	key_init();
	security_init();
	dbg_late_init();
	vfs_caches_init(totalram_pages);
	signals_init();

	page_writeback_init();

	proc_root_init();

	cgroup_init()							// \kernel\cgroup.c							
	{										//[    0.495501] WA2301:Initializing cgroup subsys debug
		for (i = 0; i < n; i++) {			//[    0.495550] WA2301:Initializing cgroup subsys cpuacct
			cgroup_init_subsys(ss);			//[    0.495600] WA2301:Initializing cgroup subsys freezer
		}
	}

	cpuset_init();
	taskstats_init_early();
	delayacct_init();

	check_bugs();

	acpi_early_init(); /* before LAPIC and SMP init */
	sfi_init_late();

	ftrace_init();

	/* Do the rest non-__init'ed, we're now alive */
	rest_init()							 //该函数打印了大部分日志，约5/6,前面有1/6
	{
		rcu_scheduler_starting();										//None print
		kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);		//kernel_init 见下文分析
		numa_default_policy();											//
		pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);	//
		rcu_read_lock();												//
		kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);			//
		rcu_read_unlock();												//
		complete(&kthreadd_done);										//
																		//
		/*																//
		 * The boot idle thread must execute schedule()					//
		 * at least once to get things moving:							//
		 */																//
		init_idle_bootup_task(current);									//
		preempt_enable_no_resched();									//None print
		schedule()														//即开始运行kernel_init 进程
		{

		}

		preempt_disable();												//[    0.933797] s5pv210-uart.1: ttySAC1 at MMIO 0xe2900400 (irq = 20) is a S3C6400/10

		/* Call into cpu_idle with preempt disabled */
		cpu_idle()														// arch\arm\kernel\process.c 
		{																
			local_fiq_enable();

			/* endless idle loop with no priority at all */
			while (1) {
				idle_notifier_call_chain(IDLE_START);
				tick_nohz_stop_sched_tick(1);
				while (!need_resched()) {

					local_irq_disable();
					if (hlt_counter) {
						local_irq_enable();
						cpu_relax();
					} else {
						stop_critical_timings();
						pm_idle();
						start_critical_timings();
						/*
						 * This will eventually be removed - pm_idle
						 * functions should always return with IRQs
						 * enabled.
						 */
						WARN_ON(irqs_disabled());
						local_irq_enable();
					}
				}
				tick_nohz_restart_sched_tick();
				idle_notifier_call_chain(IDLE_END);
				preempt_enable_no_resched();
				schedule();
				preempt_disable();
			}

		}

	}
	
	/* WA2301:Never run here */
}




kernel_init()
{
	wait_for_completion(&kthreadd_done);
	set_mems_allowed(node_states[N_HIGH_MEMORY]);
	set_cpus_allowed_ptr(current, cpu_all_mask);

	cad_pid = task_pid(current);

	smp_prepare_cpus(setup_max_cpus);

	do_pre_smp_initcalls();
	lockup_detector_init();

	smp_init();
	sched_init_smp();

	do_basic_setup()
	{
		cpuset_init_smp();
		usermodehelper_init();
		init_tmpfs();
		driver_init();
		init_irq_proc();
		do_ctors();
		do_initcalls()						//大多数外部驱动，如按键、LED、USB等在这里调用
		{									//驱动代码见 drivers/char/mini210...c，裁剪只需屏蔽 drivers/char/Makefile
			for (fn = __early_initcall_end; fn < __initcall_end; fn++)
			{
				do_one_initcall(*fn);		//约500多次循环
			}
		}
	}
											//至此，初始化基本完成，准备加载rootfs


	/* Open the /dev/console on the rootfs, this should never fail */
	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
		printk(KERN_WARNING "Warning: unable to open an initial console.\n");
											// ‘/dev/console’为kernel_init打开的第一个文件
											// 此处erase整个nand后出现异常，说明加载的fs位于nand,经验证，
											//用Mini_tools只烧写rootfs_rtm_210.img即可运行，同时说明www文件夹位于其他rootfs_xxx.img中，Mini_tools烧写位置不明
											//[root@FriendlyARM share]# cat /proc/partitions
												major     minor    #blocks  name

												  31        0        256 mtdblock0
												  31        1       5120 mtdblock1
												  31        2       5120 mtdblock2
												  31        3       3072 mtdblock3
												  31        4    1034240 mtdblock4
												 179        0     980992 mmcblk0
											[root@FriendlyARM share]# df -h
											Filesystem                Size      Used Available Use% Mounted on
											/dev/mtdblock4         1010.0M     16.3M    993.7M   2% /
											tmpfs                   193.4M         0    193.4M   0% /dev/shm
											//此处与 最前面 Kernel command line: root=/dev/mtdblock4 一致

											[    1.137053] Creating 5 MTD partitions on "s5pv210-nand":
											[    1.137105] 0x0000000c0000-0x000000100000 : "misc"
											[    1.142923] 0x000000100000-0x000000600000 : "recovery"
											[    1.149563] 0x000000600000-0x000000b00000 : "kernel"
											[    1.154472] 0x000000b00000-0x000000e00000 : "ramdisk"
											[    1.158765] 0x000000e00000-0x000040000000 : "system"  -- 即上面的 mtdblock4共1010M

											经测试，rootfs_rtm_210.img 被Mini_Tools写入nand 0xE00000 位置

	

	(void) sys_dup(0);
	(void) sys_dup(0);

	if (!ramdisk_execute_command)			//用户启动或uboot启动时传入的参数是不是这里生效？
		ramdisk_execute_command = "/init";	//

	if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
		ramdisk_execute_command = NULL;
		prepare_namespace() 				//Prepare the namespace - decide what/where to mount, load ramdisks, etc.
		{
											//当擦除nand中全部数据（主要是rootfs）后会运行这里

		}
	}



	init_post()
	{
		async_synchronize_full();
		free_initmem();
		mark_rodata_ro();
		system_state = SYSTEM_RUNNING;
		numa_default_policy();

		if (ramdisk_execute_command) {		
			run_init_process(ramdisk_execute_command);
											//initramfs模式，启动init（老的ramdisk模式启动第一个为linuxrc）???
											//进入用户进程 init,第一个用户级进程(PID = 1)，是所有其它进程的父进程，引导用户空间服务。
											//详见ramdisk 由include\generated\autoconf.h 配置
											//              #define CONFIG_INITRAMFS_SOURCE "scripts/FriendlyARM.cpio"
											//基本脱离kernel进入rootfs层
			printk(KERN_WARNING "Failed to execute %s\n",
					ramdisk_execute_command);
		}







									
											//一般情况不会到这里，上面的“/init”会启动成功
		if (execute_command) {				//WA2301:We try each of these until one succeeds.
			run_init_process(execute_command);
			printk(KERN_WARNING "Failed to execute %s.  Attempting "
						"defaults...\n", execute_command);
		}
		run_init_process("/sbin/init");
		run_init_process("/etc/init");
		run_init_process("/bin/init");
		run_init_process("/bin/sh");

		panic("No init found.  Try passing init= option to kernel. "
			  "See Linux Documentation/init.txt for guidance.");
	}										//文件系统中无init，一般为文件系统挂载异常
	
	return 0;								//WA2301:Never return
}









module_init ;//机制，动态加载模块，大多数驱动采用此种模式，可自由选配，节省内核空间









   zreladdr-y	:= 0x20008000
params_phys-y	:= 0x20000100

zreladdr-$(CONFIG_MACH_SMDKC110) 		 := 0x30008000
params_phys-$(CONFIG_MACH_SMDKC110)      := 0x30000100






从stext 到 start_kernel 作用：

 		1. 确定 processor type                      (75 - 78行)
        2. 确定 machine type                        (79 - 81行)
        3. 创建页表                                (82行)     
        4. 调用平台特定的__cpu_flush函数        (在struct proc_info_list中)        (94 行)                           
        5. 开启mmu                                (93行)
        6. 切换数据                                 (91行)
        最终跳转到start_kernel 












第一阶段：内核的重定向和内核的自解压

第二阶段：执行没有压缩的内核的汇编代码部分

1）获取CPU信息

2）检查平台设备号

3）创建页表

4）打开内存控制器（MMU）

5）清除BSS段

6）执行内核C语言部分入口函数

第三阶段：

1 )  获取Uboot给内核传递的参数

2）控制台初始化

3）执行init命令

4）挂载文件系统

5）执行用户空间的第一个程序


